[![build status](https://img.shields.io/travis/pandafeeder/mongo-mongo/master.svg?style=flat-square)](https://travis-ci.org/pandafeeder/mongo-mongo)
[![npm version](https://img.shields.io/npm/v/mongo-mongo.svg?style=flat-square)](https://www.npmjs.com/package/mongo-mongo)
[![Coverage Status](https://coveralls.io/repos/github/pandafeeder/mongo-mongo/badge.svg?branch=master)](https://coveralls.io/github/pandafeeder/mongo-mongo?branch=master)

# __A ES6 class based mongoDB ODM__ *which is a wrapper upon offical mongodbjs driver*


### features
- __Object based: an object representing a document in collection, with CRUD methods and all data fields are setter and getter accessor descriptors.__
- __schema: support multi constrain like type, unique, sparse, default, required and you can customize an validator function for a field.__
- __promise based: all operation return promise.__
- __decorated class mehod: class methods expose all CRUD operations with additional customization as data checking against schema defination and directly return doc for *findOneAndRepacle* *findOneAndUpdate* *findOneAndDelete* instead of a result (which you have to use result.value to get the doc in native way).__
- __native driver function exposed: you can also directly use offical driver's function via class methods whose name appended by Native or use constructed db instance from DB class.__

### required
node version >= 6
### installation
```npm install --save mongo-mongo```
### content
- <a href="#a-quick-glance">a quick glance</a>
- <a href="#db-class">DB class</a>
- <a href="#constructor">constructor</a>
- <a href="#schema-defination">schema defination</a>
- <a href="#instance-method">instance method</a>
- <a href="#class-method">class method</a>
- <a href="#native-driver-functions">native driver functions</a>
- <a href="#edge-cases">edge cases</a>
- <a href="#crud-operation">CRUD operation</a>
- <a href="#aggregate-operation">aggregate operation</a>
- <a href="#todo">Todo</a>
### a quick glance
```javascript
const { DOC, DB, types } = require('mongo-mongo')

class Book extends DOC {
    constructor(data) {
        super(data)
        this.setSchema({
            title: {type: String, unique: true},
            // if only type constrain, use this syntax for short
            publish: Date,
            created: {type: Date, default: new Date},
            copies: {
                type: types.Int,
                validator: v => (v >= 1000 && v <= 10000)
            }
            price: Number
        })
    }
    // default collection name is lower-cased class name, set it explicitly using below method
    static setCollectionName() {
        return 'books'
    }
}

// DB eats the same argument as native's MongoClient.connect
const db = new DB('mongodb://localhost:27017/db')
// all CURD operation will use the same db instance
Book.setDB(db)
// no created field supplied in argument, a default new Date will be used, this will throw error if any field not satisfying schema defination
let book = new Book({title:'2666', publish: new Date(2008,10,10), copies: 5000, price: 12.2})
// insert data into database
book.save()
    .then(r => {console.log('saved!')})
    .catch(e => {console.log('something wrong when saving')})
```


### DB class
Constructed with a mongo connect string and option, it's a wrapper upon native driver's MongoClient. Once a instance is constructed, you can get native driver's db instance via ```db.getDB(db => console.log('db is a instance of native MongoDb'))```. The point is getDB returns a thunker which delays the evaluation of a paramless async function and cache the result(thanks to thunky module), that's to say for a specific db instande, it'll establish connection to db server only once, and the afterwards calling just reuse the same connection.
###### example:
```javascript
const DB = require('mongo-mongo').DB
const db = new DB('mongodb://localhost:27017/data')//,option as second parameter if any
db.getDB(db => {}) //do whatever you want with db instance inside arrow function
```

### constructor
You can use constructor in two ways:
1. only pass data argument and set db else where via class method setDB(recommeded)
2. pass both db and data arguments

both ways support constructing with no argument and add data field latter
###### example:
```javascript
// 1. only pass data to constructor
class YourDOC1 extends DOC {
    constructor(data) {
        super(data)
        this.setSchema({name: String})//define your schema here
    }
}
// 2. pass db and data to construcotr
class YourDOC2 extends DOC {
    constructor(db, data) {
        super(db, data)
        this.setSchema({name: String})//define your schema here
    }
}

// new instance with argument, setDB else where
let yourdoc1 = new YourDOC1({name: 'name'});
YourDOC1.setDB(db);
// laterly newed instance after yourdoc2 don't need db anymore since you've set it
let yourdoc2 = new YourDOC2(db, {name: 'name'})

// new instance without argument and setDB else where
let yourdoc1_1 = new YourDOC1(); YourDOC1.setDB(db);
let yourdoc2_1 = new YourDOC2(); YourDOC2.setDB(db);
// add data via setter, every data field is a setter/getter descriptor of your instance
yourdoc1_1.name = 'name'
yourdoc2_1.name = 'name'
```

### schema defination
set schema inside constructor via ```this.setSchema({})//schma object```
###### supported types:
- String
- Number
- Int: *refer to Int like so```const Int = require('mongo-mongo').types.Int```*
- Object
- Boolean
- Array
- Date
- nested document (multi nested levels supported)
###### example for nested document
```javascript
class Author extends DOC {
  constructor(data) {
    super(data)
    this.setSchema({
      name: {type: String, required: true},
      born: Date,
      nationality: [String],
      married: Boolean
    })
  }
}

class Book extends DOC {
  constructor(data) {
    super(data)
    this.setSchema({
      title: {type: String, required: true},
      //for nested document type, use string
      author: 'Author',
      publish: Date,
      created: {type: Date, default: new Date()},
      price: Number,
      copies: {type: Int, validator: v => (v>100 && v<2000)},
      // embedded document as plain object
      recommedation: {type: Object, unique: true, sparse: true},
      // for Array, you can use Array, [], or [INNER_TYPE] as type constrain
      keywords: [String],
      soldout: Boolean,
    })
  }
  static setCollectionName() {
    return 'books'
  }
}

let author = new Author({
  name: 'Roberto BolaÃ±o',
  born: new Date(1953,3,27),
  nationality: ['Chile'],
  married: true
})

// default value of created field will be added automatically since it's not supplied
let book = new Book({
  title: '2666',
  author: author,
  publish: new Date(2008,10,10),
  price: 15.2,
  copies: 1500,
  recommedation: {
    reviewer: 'New York Times',
    comment: '10 Best Books of 2008'
  },
  keywords: ['history', 'novel'],
  soldout: true
})
```

###### supported constrains:
- type: define a field's type, if you only want type constrain, use *```fieldName: TYPE```* for short
- unique: this will create a index by calling mongodb's native ```createIndex('yourFieldName', {unique: true})``` once for a DOC class
- default: when no value supplied, default will be used
- required: throw error when construct a new instance with data argument but no required field supplied or throw error when calling save if you construct instance without data argument
- sparse: this will create a index by calling mongodb's native ```createIndex('yourFieldName', {sparse: true})``` once for a DOC class
- validator: this must be a function which return boolean

### instance method
- for CRUD opeartion, please reder to <a href="#crud-operation">CRUD operation</a>
- retrive or set data field with setter or getter
- save: save your instance's data into database, every instance has a __data property(unenumerable) refer to its doc data
- update: use setter update your instance's data then use update to update into database
- delete: delete corresponding doc from database
- getData: return data object referred by __data property, if there's nested field, the corresponding filed is a instanct of nested document
- addData: you can add multi fields' data using this method

### class method
- for CRUD opeartion, please reder to <a href="#crud-operation">CRUD operation</a>
- getCollection: require a callback as parameter and pass the underlying collection instance to callback function
- getDB: require a callback as parameter and pass the underlying db instance to callback function
- setDB: set db instance to use for your DOC class
- setCollectionName: default collction name for a DOC class is its lower-cased name, you can specify it by define a static method called setCollectionName and return wanted string when declaring your DOC class

### native driver functions
- for CRUD opeartion, please reder to <a href="#crud-operation">CRUD operation</a>

### aggregate operation
all following class methods accept the same argument as corresponding native function, all result is returned in a promise
- aggregate
- mapReduce
- count
- distinct
- bulkWrite

### edge cases
- class method *updateOne/updateMany* don't support nested document right now, and don't support the following update operators: ```$inc, $mul, $rename, $min, $max, $addToSet, $setOnInsert```. The reason is that these operators need previous value, let's say a field has constrain as ```v <=100 && v >=90``` and its previous value is 100, $inc 1 will violate its constrain, in order to check against shcema defination, we have to retrive previous value first and do the caculation, this seems cubersome. Maybe we can add another function for above concern in later version.
- for Object field, you have to assign new object to trigger __updatedField, when calling a setter of a field, it push that field name into __updatedField array to keep track of which field is updated, but for a Object field, we set its property via instance.ObjectField.propery, this is actually calling a getter, thus no chance to update __updatedField, so if you update a nested Object property, please re-assign that field to trigger updating __updatedField, I made some extra effort for nested document, so nested document has no such limit, you should consider using a nested document over a nest Object in this condition.

### CRUD operation
| operatrion | instance method | class method | native driver(via class method) |
| ------     | ------          | ------       |           ------                |
| Create     |  save           | insertOne    |        insertOneNative          |
| Create     |  save           | insertMany   |        insertManyNative         |
| Read       |  getter         | find         |        find                     |
| Read       |  getter         | findOne      |        findOneNative            |
| Update     |  setter + update | updateOne   |        updateOneNative          |
| Update     |  setter + update | replaceOne  |        replaceOneNative         |
| Update     |  setter + update | updateMany  |        updateManyNative         |
| Delete     |  delete         | deleteOne    |        deleteOneNative          |
| Delete     |  delete         | deleteMany   |        deleteManyNative         |
| Read and Update | getter + update | findOneAndUpdate | findOneAndUpdateNative |
| Read and Update | getter + update | findOneAndReplace| findOneAndReplaceNative|
| Read and Delete | getter + delete | findOneAndDelete | findOneAndDeleteNative |

| operation               | called-via  |           explaination         |  exmaple |
| ------                  | ------      |              ------            |  ------  |
| save                    | instance    | insert instance's doc data into db, return promise | ```book.save().then(r => console.log('saved'))```  |
| getter/setter           | instance    | get/set instance's data field      | ```book.price; book.price = 20``` |
| update                  | instance    | update instance's data into db, return promise | ```book.update().then(r => console.log('updated'))```    |
| delete                  | instance    | delete instance's data from db, return promise | ```book.delete().then(r => console.log('deleted'))```    |
| insertOne               | class       | insert doc into db, have the ability of checking doc data against schema defination, return primose | ```Book.insertOne({title: 'Last Evenings on Earth', publish: new Date(2007,3,30)}).then(r => console.log('inserted'))``` |
| insertMany              | class       | insert many docs into db, have the ability of checking docs' data against schema defination, return promise | ```Book.insertMany([{title: 'title1'},{title: 'title2'}]).then(r => console.log('inserted'))```|
| insertOneNative         | class       | call native driver's insertOne, doesn't check data's validation, return promise | ```Book.insertOne({title: 'title insert by native driver'}).then(r => console.log('inserted'))``` |
| insertManyNative        | class       | call native driver's insertMany, doesn't check data's validation, return promise | ```Book.insertOne([{title: 'title1'},{title: 'title2'}]).then(r => console.log('inserted'))``` |
| find                    | class       | call native driver's find, return cursor in a promise | ```Book.find({title: '2666'}).then(cursor => cursor.toArray())``` |
| findOne                 | class       | call native driver's findOne, return matched doc in a promise | ```Book.findOne({title: '2666'}).then(doc => doc.title === '2666')``` |
| findOneNative           | class       | same as findOne | ```Book.findOneNative({title: '2666'}).then(doc => doc.title === '2666')```
| updateOne               | class       | update a matched doc, have the ability of checking updating data against schema defination, return promise | ```Book.updateOne({title: '2666'}, {$set: {copies: 8000}}).then(r => console.log('updated'))```
| updateOneNative         | class       | update a matched doc, doesn't check updating data's validation, return promise |```Book.updateOneNative({title: '2666'}, {$set: {copies: 20000}}).then(r => console.log('updated'))```
| replaceOne              | class       | replace a matched doc, have the ability of checking replacing data against schema defination, return promise | ```Book.replaceOne({title: '2666'},{title: 'new 2666'}).then(r => console.log('replaced'))```|
| replaceOneNative        | class       | replace a matched doc, doesn't check data's validation, return promise | ```Book.replaceOneNative({title: '2666'},{title: 'new 2666'}).then(r => console.log('replaced'))```|
| updateMany              | class       | update many matched docs, have the ability of checking updating data against schema defination, return promise |```Book.updateMany({title: /title/},{$set: {copies: 6000}}).then(r => console.log('updated'))```|
| updateManyNative        | class       | update many matched docs, doesn't check updating data's validation, return promise | ```Book.updateManyNative({title: /title/},{$set: {copies: 20000}}).then(r => console.log('updated'))``` |
| deleteOne               | class       | delete a matched doc, return promise | ```Book.deleteOne({title: '2666'}).then(r => console.log('deleted'))``` |
| deleteOneNative         | class       | same as deleteOne | ```Book.deleteOne({title: '2666'}).then(r => console.log('deleted'))``` |
| deleteMany              | class       | delete many matched docs, return promise | ```Book.deleteMany({title: /title/}).then(r => console.log('deleted'))``` |
| deleteManyNative        | class       | same as deleteMany | ```Book.deleteMany({title: /title/}).then(r => console.log('deleted'))``` |
| findOneAndUpdate        | class       | update a matched doc and return original or updated doc according to returnOriginal option in a promise, have the ability of checking updating data against schema defination | ```Book.findOneAndUpdate({title: '2666'},{$set: {copies: 6000}}).then(doc => doc.copies === 5000)``` |
| findOneAndUpdateNative  | class       | update a matched doc and return operation result in a promise, result.value is original or updated is according to returnOriginal option, doesn't check updating data's validation | ```Book.findOneAndUpdateNative({title: '2666'},{$set: {copies: 20000}}).then(result => result.value.copies === 5000)``` |
| findOneAndReplace       | class       | replace a matched doc and return original or replaced doc according to returnOriginal option in a promise, have the ability of checking replacing data against schema defination | ```Book.findOneAndReplace({title: '2666'},{title: '2666', copies: 6000}).then(doc => doc.copies === 5000)``` |
| findOneAndReplaceNative | class       | replace a matched doc and return operation result in a promise, result.value is original or replaced is according to returnOriginal option, doesn't check replacing data's validation | ```Book.findOneAndReplaceNative({title: '2666'},{title: '2666', copies: 20000}).then(result => result.value.copies === 5000)``` |
| findOneAndDelete        | class       | delete a matched doc and return original doc in a promise | ```Book.findOneAndDelete({title: '2666'}).then(doc => doc.title === '2666')``` |
| findOneAndDeleteNative  | class       | delete a matched doc and return operation result in a promise | ```Book.findOneAndDeleteNative({title: '2666'}).then(result => result.value.title === '2666')``` |

### Todo
- support more types
- add new class method to do update operation with supporting of all update operator

## ä¸­æ

### ç¹æ§
- __åºäºå¯¹è±¡: ä¸ä¸ªå¯¹è±¡ä»£è¡¨collectionä¸­çä¸ä¸ªdocument, å¯¹è±¡æ¥æCRUDæ¹æ³ï¼å¯¹è±¡çæ¯æ¡data fieldå¯¹åºä¸ç»setter/getteræè¿°ç¬¦ã__
- __schema: æ¯æå¤ç§çº¦æ:type, unique, sparse, default, required ä½ ä¹å¯ä»¥èªå®ä¹validator function.__
- __è¿åpromise: CRUDæä½é½è¿åpromise.__
- __éå åè½çç±»CRUDæ¹æ³: classé¤äºç´æ¥æ´é²åççCRUDæ¹æ³å¤(è¦ä½¿ç¨åçæ¹æ³å¨å¯¹åºæ¹æ³ååå Native)ï¼è¿å¯¹inertï¼updateï¼replaceç­åæä½åäºæ°æ®æææ§æ£æ¥, *findOneAndRepacle* *findOneAndUpdate* *findOneAndDelete* æ¹æ³ç´æ¥ædocæ°æ®åè£å¨promiseä¸­è¿åï¼èä¸æ¯ååçæ¹æ³é£æ ·éè¦è®¿é®æä½ç»æçvalueå±æ§å¾å°docæ°æ®ã__

### ç®å½  
- <a href="#æ«ä¸ç¼">æ«ä¸ç¼</a>
- <a href="#DB-ç±»">DB ç±»</a>
- <a href="#æé å½æ°">æé å½æ°</a>
- <a href="#schema-å®ä¹">schema å®ä¹</a>
- <a href="#å®ä¾æ¹æ³">å®ä¾æ¹æ³</a>
- <a href="#ç±»æ¹æ³">ç±»æ¹æ³</a>
- <a href="#å®æ¹åçå½æ°">å®æ¹åçå½æ°</a>
- <a href="#è¾¹çæåµ">è¾¹çæåµ</a>
- <a href="#CRUD-æä½">CRUD æä½</a>
- <a href="#è®¡å">è®¡å</a>


### æ«ä¸ç¼
```javascript
const { DOC, DB, types } = require('mongo-mongo')

class Book extends DOC {
    constructor(data) {
        super(data)
        this.setSchema({
            title: {type: String, unique: true},
            // å¦æåªæç±»åéå¶ï¼é£ä¹ä½¿ç¨ä¸é¢çç®åå½¢å¼
            publish: Date,
            created: {type: Date, default: new Date},
            copies: {
                type: types.Int,
                validator: v => (v >= 1000 && v <= 10000)
            }
            price: Number
        })
    }
    // é»è®¤çcollectionçåå­ä¸ºç±»åçå¨å°åï¼å¯ä»¥ä½¿ç¨ä¸é¢çæ¹æ³æ¥æ¾å¼è®¾ç½®collectionåå­
    static setCollectionName() {
        return 'books'
    }
}

// ä¼ ç»DBçåæ°ä¸åççMongoClient.connectåæ°ä¸è´
const db = new DB('mongodb://localhost:27017/db')
// ä¹åææçCRUDæä½é½æ¯å¤ç¨åä¸ä¸ªdbå®ä¾
Book.setDB(db)
// å ä¸ºä¼ å¥åæ°æ²¡æcreatedå¼ï¼createdå°ä½¿ç¨defaultè®¾å®çnew Date,å¦æä¼ å¥çåæ°è¿åschemaçå®ä¹ï¼å°æåºéè¯¯
let book = new Book({title:'2666', publish: new Date(2008,10,10), copies: 5000, price: 12.2})
// ådatabaseæå¥æ°æ®
book.save()
    .then(r => {console.log('saved!')})
    .catch(e => {console.log('something wrong when saving')})
```


### DB ç±»

DB ç±»åäºä¸å±å®æ¹çMongoClient.connect, åå»ºå®ä¾çåæ°ä¸ä¼ éç»MongoClient.connectçåæ°ä¸è´ãæé åºå®ä¾åå¯ä»¥éè¿å®ä¾æ¹æ³```db.getDB(db => {})```æ¿å°å®æ¹çdbå®ä¾ãgetDBå®éä¸è¿åä¸ä¸ªthunkerï¼å¯¹äºæ¯ä¸ä¸ªå®ä¾ï¼åªä¸db serverå»ºç«ä¸æ¬¡é¾æ¥ï¼ä»¥åæ¯æ¬¡ådbçæä½ï¼å®éä¸é½æ¯å¨å¤ç¨ä¹åçdbå®ä¾ã
###### ä¾å­:
```javascript
const DB = require('mongo-mongo').DB
const db = new DB('mongodb://localhost:27017/data')//,optionéè¿ç¬¬äºä¸ªåæ°ä¼ é
db.getDB(db => {db}) //å¨ç®­å¤´å½æ°åå¾å°å®æ¹db
```

### æé å½æ°
ä½ å¯ä»¥ä½¿ç¨ä»¥ä¸ä¸¤ç§æ¹æ³å®ä¹æé å½æ°:
1. ä»ä¼ édataå½¢åï¼ç¶åå¨å¶ä»å°æ¹éè¿setDBç±»æ¹æ³æ¥æå®è¦ä½¿ç¨çdbå®ä¾(æ¨è)
2. ä¼ édb, dataä¸¤ä¸ªå½¢å

ä¸¤ç§æ¹å¼é½æ¯ænewå®ä¾æ¶ï¼ä¸æä¾ä»»ä½åæ°ï¼ç¨ååæ·»å æ°æ®
###### ä¾å­:
```javascript
// 1. ä»ä¼ édataå½¢å
class YourDOC1 extends DOC {
    constructor(data) {
        super(data)
        this.setSchema({name: String})//å®ä¹schema
    }
}
// 2. ä¼ édbådataå½¢å
class YourDOC2 extends DOC {
    constructor(db, data) {
        super(db, data)
        this.setSchema({name: String})//å®ä¹schema
    }
}

// å¸¦dataå®åæé å®ä¾ï¼ç¨setDBæå®è¦ä½¿ç¨çdbå®ä¾
let yourdoc1 = new YourDOC1({name: 'name'});
YourDOC1.setDB(db);
// å¸¦dbådataå®åæé å®ä¾ï¼ä¹åæé çå®ä¾ä¸å¿åæä¾dbå®åï¼å ä¸ºç¬¬ä¸æ¬¡å·²ç»æä¾äº
let yourdoc2 = new YourDOC2(db, {name: 'name'})

// ä¸å¸¦ä»»ä½å®åæé å®ä¾,ç¨setDBæå®è¦ä½¿ç¨çdbå®ä¾
let yourdoc1_1 = new YourDOC1(); YourDOC1.setDB(db);
let yourdoc2_1 = new YourDOC2(); YourDOC2.setDB(db);
// éè¿setteræ·»å æ°æ®, æ¯ä¸ä¸ªschemaä¸­å®ä¹çæ°æ®é½æ¯ä¸ä¸ªsetter/getteræè¿°ç¬¦
yourdoc1_1.name = 'name'
yourdoc2_1.name = 'name'
```

### schema å®ä¹
å¨æé å½æ°åéè¿æ¥å®ä¹```this.setSchema({})//åæ°ä¸ºschemaå¯¹è±¡```schema
###### æ¯æçç±»å:
- String
- Number
- Int: *éè¿```const Int = require('mongo-mongo').types.Int```æ¥ä½¿ç¨Int*
- Object
- Boolean
- Array
- Date
- nested document (æ¯æä»»æå±çº§çåµå¥)
###### nested document ä¾å­
```javascript
class Author extends DOC {
  constructor(data) {
    super(data)
    this.setSchema({
      name: {type: String, required: true},
      born: Date,
      nationality: [String],
      married: Boolean
    })
  }
}

class Book extends DOC {
  constructor(data) {
    super(data)
    this.setSchema({
      title: {type: String, required: true},
      //ä½¿ç¨å­ç¬¦ä¸²æ¥å®ä¹ nested document ç±»å
      author: 'Author',
      publish: Date,
      created: {type: Date, default: new Date()},
      price: Number,
      copies: {type: Int, validator: v => (v>100 && v<2000)},
      // åµå¥çº¯Object
      recommedation: {type: Object, unique: true, sparse: true},
      // å¯ä»¥ä½¿ç¨Array,æ[],æ[ç±»å]æ¥å®ä¹
      keywords: [String],
      soldout: Boolean,
    })
  }
  static setCollectionName() {
    return 'books'
  }
}

let author = new Author({
  name: 'Roberto BolaÃ±o',
  born: new Date(1953,3,27),
  nationality: ['Chile'],
  married: true
})

// å®åæ²¡æä¾created, createdå°ä½¿ç¨é»è®¤å¼
let book = new Book({
  title: '2666',
  author: author,
  publish: new Date(2008,10,10),
  price: 15.2,
  copies: 1500,
  recommedation: {
    reviewer: 'New York Times',
    comment: '10 Best Books of 2008'
  },
  keywords: ['history', 'novel'],
  soldout: true
})
```

###### çº¦ææ¡ä»¶:
- type: æå®ç±»åçº¦æ, å¦æä½ å¯¹æä¸ªdata fieldåªæç±»åä¸ççº¦æ, å¯ä»¥ä½¿ç¨*```fieldName: TYPE```*ç®å
- unique: å¦ææå®æä¸ªdata fieldä¸ºunique, åä¼å¨é¦æ¬¡CRUDæä½ä¹åè°ç¨åçç```createIndex('yourFieldName', {unique: true})```æ¥åå»ºunique index 
- default: å½è¯¥data fieldå¼æªæä¾æ¶ï¼ä½¿ç¨é»è®¤å¼
- required: ä¸ºtrueæ¶ï¼å½æä¾çdataç¼ºå°è¯¥æ¡ç®åæåºerror
- sparse: å¦ææå®æ¸ä¸ªdata fieldä¸ºspareæ¶ï¼åä¼å¨é¦æ¬¡CRUDæä½ä¹åè°ç¨åçç```createIndex('yourFieldName', {sparse: true})```æ¥åå»ºspare index
- validator: èªå®ä¹æ£æ¥å½æ°ï¼è¯¥å½æ°éè¿åbooleanå¼

### å®ä¾æ¹æ³
- è¯¦ç»çCRUDæä½è¯·åè <a href="#crud-æä½">CRUD operation</a>
- åå¼ï¼èµå¼ä½¿ç¨setter, getteræè¿°ç¬¦
- save: æå¥å®ä¾çdataå°æ°æ®åºä¸­ï¼æ¯ä¸ªå®ä¾é½æä¸ä¸ª__dataå±æ§(unenumerable)æåå¶åå³æ°æ®
- update: ä½¿ç¨setterèµæ°åï¼ç¶åè°ç¨updateåæ°æ®åºåèµ·æ´æ°
- delete: å ææ°æ®åºä¸­è¯¥instanceææåçæ°æ®
- getData: è¿å__dataå±æ§æåçæ°æ®ï¼å½æåµå¥ç±»åæ¶ï¼è¯¥fieldè¿ååµå¥çdocumentå®ä¾
- addData: ä½ å¯ä»¥éè¿addDataä¸æ¬¡æ·»å å¤æ¡æ°æ®


### ç±»æ¹æ³
- è¯¦ç»çCRUDæä½è¯·åè <a href="#crud-æä½">CRUD operation</a>
- getCollection: åæ°ä¸ºcallbackå½æ°ï¼ä¼ éç»callbackå½æ°çåæ°ä¸ºmongodb collectionå®ä¾
- getDB: åæ°ä¸ºcallbackå½æ°ï¼ä¼ éç»callbackå½æ°çåæ°ä¸ºmongodb dbå®ä¾
- setDB: è®¾ç½®è¯¥ç±»æä½¿ç¨çDBå®ä¾
- setCollectionName: ä¸ä¸ªç±»å¯¹åºçcollection nameé»è®¤ä¸ºç±»åå¨å°åï¼å¯ä»¥éè¿è¯¥å½æ°æ¾å¼è®¾ç½®collection name

### å®æ¹åçå½æ°
- è¯¦ç»çCRUDæä½è¯·åè <a href="#crud-æä½">CRUD operation</a>

### aggregateæä½
ä¸é¢ææçæä½ä¸åçå½æ°æ¥æ¶çåæ°å®å¨ä¸è´ï¼æç»æåå¨promiseä¸­è¿å
- aggregate
- mapReduce
- count
- distinct
- bulkWrite


### è¾¹çæåµ
- ç±»æ¹æ³ *updateOne/updateMany* ç®åä¸æ¯ænested document ä¹ä¸æ¯æå¦ä¸update operator: ```$inc, $mul, $rename, $min, $max, $addToSet, $setOnInsert```. åå ä¸ºä»¥ä¸operatoréè¦æ´æ°åæ°æ®çå¼ï¼æ¯å¦è¯´ï¼ä½ æä¸ä¸ªdata fieldéè¿validatorçº¦æä¸º ```v <= 100 && v >= 90```,æ­¤æ¶æ´æ°åçæ°æ®ä¸º100ï¼é£ä¹$inc 1çæä½ä¼ç ´åè¯¥çº¦æï¼è¿æ ·çæä½éè¦åå»queryå°å½åå¼ï¼ç¶ååè¿è¡è®¡ç®ï¼æ£æ¥ç¬¦ä¸ç¬¦åçº¦æï¼å¯¼è´å¯¹updateè¿æ ·ä¸ä¸ªæä½æ¥è®²ï¼æ§è½æ¬ ä½³ï¼å¯è®¸å¯ä»¥èèä»¥ååæ°å ä¸ä¸ªè¿æ ·çæ¹æ³ã
- å¯¹äºç±»åä¸ºObjectçdata fieldï¼å¦æè¦æ´æ°è¯¥Objectå¶ä¸­ä¸æ¡å±æ§çå¼åæ³è¦è§¦å__updateFieldçæ´æ°ï¼é£ä¹ä½ å¿é¡»è¦éæ°ç»è¯¥data fieldèµå¼ä¸ä¸ï¼åå æ¯å½ç»data fieldèµå¼æ¯å®éä¸æ¯è°ç¨äºè¯¥fieldçsetterï¼setteréé¢ä¼æä¸ä¸ªæä½æ¥å§è¯¥data fieldçåå­pushå°__updatedFieldä¸­ï¼è¿æ ·å¨updateæä½æ¶ï¼æå»æåææ°çå¼ãä½æ¯å¯¹äºObjectç±»åçfieldæ¥è®²ï¼æä»¬ä¸è¬ä¼ç¨è¿æ ·çæ¹å¼æ¥æ´æ°Objectçæä¸ªpropertyçå¼```instance.ObjectField.property = 'xxxxx'```,è¿æ ·çæä½å®éä¸æ¯è°ç¨è¯¥fieldçgetterï¼æ²¡åæ³è°ç¨setterä¹å°±æ²¡åæ³æ´æ°__updatedFieldï¼æä»¥ä½ éè¦å¯¹è¯¥fieldè¿è¡èµå¼æä½ï¼```instance.ObjectField = updatedObject```æ¥è§¦å__updatedFieldçæ´æ°ãå¯¹äºnested documentæ¥è®²ï¼æåäºäºé¢å¤çæä½æ¥é¿åç±»ä¼¼çæåµï¼æ éæ­¤é¡¾èãæä»¥ï¼è¿æ ·çæåµä¸ï¼æ¨èèèä½¿ç¨nested documentã

### CRUD æä½
| operatrion | instance method | class method | native driver(via class method) |
| ------     | ------          | ------       |           ------                |
| Create     |  save           | insertOne    |        insertOneNative          |
| Create     |  save           | insertMany   |        insertManyNative         |
| Read       |  getter         | find         |        find                     |
| Read       |  getter         | findOne      |        findOneNative            |
| Update     |  setter + update | updateOne   |        updateOneNative          |
| Update     |  setter + update | replaceOne  |        replaceOneNative         |
| Update     |  setter + update | updateMany  |        updateManyNative         |
| Delete     |  delete         | deleteOne    |        deleteOneNative          |
| Delete     |  delete         | deleteMany   |        deleteManyNative         |
| Read and Update | getter + update | findOneAndUpdate | findOneAndUpdateNative |
| Read and Update | getter + update | findOneAndReplace| findOneAndReplaceNative|
| Read and Delete | getter + delete | findOneAndDelete | findOneAndDeleteNative |

| operation               | called-via  |           explaination         |  exmaple |
| ------                  | ------      |              ------            |  ------  |
| save                    | instance    | åå¥å®ä¾çdataæ°æ®å°databaseï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```book.save().then(r => console.log('saved'))```  |
| getter/setter           | instance    | åå¼ï¼èµå¼ å®ä¾çdata field | ```book.price; book.price = 20``` |
| update                  | instance    | æ´æ°å®ä¾ä¸­è¢«æ´æ°çdataå°databaseï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```book.update().then(r => console.log('updated'))```    |
| delete                  | instance    | ä»databaseä¸­å é¤å®ä¾çdataæ°æ®ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```book.delete().then(r => console.log('deleted'))```    |
| insertOne               | class       | åå¥ä¸æ¡dataå°databaseä¸­ï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥dataçæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.insertOne({title: 'Last Evenings on Earth', publish: new Date(2007,3,30)}).then(r => console.log('inserted'))``` |
| insertMany              | class       | åå¥å¤æ¡dataå°databaseä¸­ï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥dataçæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.insertMany([{title: 'title1'},{title: 'title2'}]).then(r => console.log('inserted'))```|
| insertOneNative         | class       | ç´æ¥è°ç¨åççinsertOneå½æ°ï¼ä¸æ£æ¥dataçæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.insertOne({title: 'title insert by native driver'}).then(r => console.log('inserted'))``` |
| insertManyNative        | class       | ç´æ¥è°ç¨åççinsertManyå½æ°ï¼ä¸æ£æ¥dataçæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.insertOne([{title: 'title1'},{title: 'title2'}]).then(r => console.log('inserted'))``` |
| find                    | class       | ç´æ¥è°ç¨åççfindå½æ°ï¼cursoråè£å¨promiseä¸­è¿å | ```Book.find({title: '2666'}).then(cursor => cursor.toArray())``` |
| findOne                 | class       | ç´æ¥è°ç¨åççfindOneå½æ°, å¹éå°çdocåè£å¨promiseä¸­è¿å | ```Book.findOne({title: '2666'}).then(doc => doc.title === '2666')``` |
| findOneNative           | class       | ä¸findOneç¸å | ```Book.findOneNative({title: '2666'}).then(doc => doc.title === '2666')```
| updateOne               | class       | æ´æ°å¹éå°çdocï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥æ´æ°dataçæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.updateOne({title: '2666'}, {$set: {copies: 8000}}).then(r => console.log('updated'))```
| updateOneNative         | class       | æ´æ°å¹éå°çdocï¼ä¸æ£æ¥æ´æ°dataçæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å |```Book.updateOneNative({title: '2666'}, {$set: {copies: 20000}}).then(r => console.log('updated'))```
| replaceOne              | class       | æ¿æ¢å¹éå°çdocï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥æ¿æ¢æ°æ®çæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.replaceOne({title: '2666'},{title: 'new 2666'}).then(r => console.log('replaced'))```|
| replaceOneNative        | class       | ç´æ¥è°ç¨åççreplaceOneå½æ°ï¼ä¸æ£æ¥æ¿æ¢æ°æ®çæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.replaceOneNative({title: '2666'},{title: 'new 2666'}).then(r => console.log('replaced'))```|
| updateMany              | class       | æ´æ°å¤æ¡å¹éå°çdocï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥æ´æ°æ°æ®çæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å |```Book.updateMany({title: /title/},{$set: {copies: 6000}}).then(r => console.log('updated'))```|
| updateManyNative        | class       | ç´æ¥è°ç¨åççupdateManyå½æ°ï¼ä¸æ£æ¥æ´æ°æ°æ®çæææ§ï¼æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.updateManyNative({title: /title/},{$set: {copies: 20000}}).then(r => console.log('updated'))``` |
| deleteOne               | class       | ç´æ¥è°ç¨åçdeleteOne, ä»databaseä¸­å é¤ä¸æ¡å¹éå°çdoc,æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.deleteOne({title: '2666'}).then(r => console.log('deleted'))``` |
| deleteOneNative         | class       | ä¸deleteOneç¸å | ```Book.deleteOne({title: '2666'}).then(r => console.log('deleted'))``` |
| deleteMany              | class       | ç´æ¥è°ç¨åçdeleteMany, ä»databaseä¸­å é¤å¤æ¡å¹éå°çdoc,æä½ç»æåè£å¨promiseä¸­è¿å | ```Book.deleteMany({title: /title/}).then(r => console.log('deleted'))``` |
| deleteManyNative        | class       | ä¸deleteManyç¸å | ```Book.deleteMany({title: /title/}).then(r => console.log('deleted'))``` |
| findOneAndUpdate        | class       | æ´æ°ä¸æ¡å¹éå°çdocï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥æ´æ°æ°æ®çæææ§ï¼æ´æ°åææ´æ°åæ°æ®(ç±option returnOriginalå³å®ï¼é»è®¤ä¸ºtrue)è¢«åè£å¨promiseä¸­è¿å | ```Book.findOneAndUpdate({title: '2666'},{$set: {copies: 6000}}).then(doc => doc.copies === 5000)``` |
| findOneAndUpdateNative  | class       | ç´æ¥è°ç¨åçfindOneAndUpdate, ä¸æ£æ¥æ´æ°æ°æ®çæææ§ï¼æä½ç»æè¢«åè£å¨promiseä¸­è¿åï¼éè¿.valueè·åæ´æ°åæä¹åæ°æ®(ç±option returnOriginalå³å®ï¼é»è®¤ä¸ºtrue)| ```Book.findOneAndUpdateNative({title: '2666'},{$set: {copies: 20000}}).then(result => result.value.copies === 5000)``` |
| findOneAndReplace       | class       | æ¿æ¢ä¸æ¡å¹éå°çdocï¼ä¼ä¾æ®schemaå®ä¹æ£æ¥æ¿æ¢æ°æ®çæææ§ï¼æ´æ°åææ´æ°åæ°æ®(ç±option returnOriginalå³å®ï¼é»è®¤ä¸ºtrue)è¢«åè£å¨promiseä¸­è¿å | ```Book.findOneAndReplace({title: '2666'},{title: '2666', copies: 6000}).then(doc => doc.copies === 5000)``` |
| findOneAndReplaceNative | class       | ç´æ¥è°ç¨åçfindOneAndReplace,ä¸æ£æ¥æ¿æ¢æ°æ®çæææ§ï¼æä½ç»æè¢«åè£å¨promiseä¸­è¿åï¼éè¿.valueè·åæ´æ°åæä¹åæ°æ®(ç±option returnOriginalå³å®ï¼é»è®¤ä¸ºtrue)| ```Book.findOneAndReplaceNative({title: '2666'},{title: '2666', copies: 20000}).then(result => result.value.copies === 5000)``` |
| findOneAndDelete        | class       | å é¤ä¸æ¡å¹éå°çdoc, è¯¥docè¢«åè£å¨promiseä¸­è¿å | ```Book.findOneAndDelete({title: '2666'}).then(doc => doc.title === '2666')``` |
| findOneAndDeleteNative  | class       | ç´æ¥è°ç¨åçfindOneAndDelete, æä½ç»æè¢«åè£å¨promiseä¸­è¿åï¼éè¿.valueè·åè¢«å é¤çdocæ°æ® | ```Book.findOneAndDeleteNative({title: '2666'}).then(result => result.value.title === '2666')``` |


### è®¡å
- æ¯ææ´å¤çæ°æ®ç±»å
- ä¹è®¸ä¼æ·»å æ°çclassæ¹æ³ç¨æ¥è¿è¡updateæä½å¹¶æ¯æææçupdate operator
